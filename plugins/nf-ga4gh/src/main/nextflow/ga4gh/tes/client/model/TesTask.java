/*
 * Copyright 2013-2024, Seqera Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Task Execution Service
 *
 * OpenAPI spec version: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package nextflow.ga4gh.tes.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import nextflow.ga4gh.tes.client.model.TesExecutor;
import nextflow.ga4gh.tes.client.model.TesInput;
import nextflow.ga4gh.tes.client.model.TesOutput;
import nextflow.ga4gh.tes.client.model.TesResources;
import nextflow.ga4gh.tes.client.model.TesState;
import nextflow.ga4gh.tes.client.model.TesTaskLog;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * Task describes an instance of a task.
 */
@Schema(description = "Task describes an instance of a task.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2023-08-15T14:10:09.878Z[GMT]")

public class TesTask {
  @SerializedName("id")
  private String id = null;

  @SerializedName("state")
  private TesState state = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("inputs")
  private List<TesInput> inputs = null;

  @SerializedName("outputs")
  private List<TesOutput> outputs = null;

  @SerializedName("resources")
  private TesResources resources = null;

  @SerializedName("executors")
  private List<TesExecutor> executors = new ArrayList<TesExecutor>();

  @SerializedName("volumes")
  private List<String> volumes = null;

  @SerializedName("tags")
  private Map<String, String> tags = null;

  @SerializedName("logs")
  private List<TesTaskLog> logs = null;

  @SerializedName("creation_time")
  private String creationTime = null;

   /**
   * Task identifier assigned by the server.
   * @return id
  **/
  @Schema(example = "job-0012345", description = "Task identifier assigned by the server.")
  public String getId() {
    return id;
  }

  public TesTask state(TesState state) {
    this.state = state;
    return this;
  }

   /**
   * Get state
   * @return state
  **/
  @Schema(description = "")
  public TesState getState() {
    return state;
  }

  public void setState(TesState state) {
    this.state = state;
  }

  public TesTask name(String name) {
    this.name = name;
    return this;
  }

   /**
   * User-provided task name.
   * @return name
  **/
  @Schema(description = "User-provided task name.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public TesTask description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Optional user-provided description of task for documentation purposes.
   * @return description
  **/
  @Schema(description = "Optional user-provided description of task for documentation purposes.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public TesTask inputs(List<TesInput> inputs) {
    this.inputs = inputs;
    return this;
  }

  public TesTask addInputsItem(TesInput inputsItem) {
    if (this.inputs == null) {
      this.inputs = new ArrayList<TesInput>();
    }
    this.inputs.add(inputsItem);
    return this;
  }

   /**
   * Input files that will be used by the task. Inputs will be downloaded and mounted into the executor container as defined by the task request document.
   * @return inputs
  **/
  @Schema(example = "[{\"url\":\"s3://my-object-store/file1\",\"path\":\"/data/file1\"}]", description = "Input files that will be used by the task. Inputs will be downloaded and mounted into the executor container as defined by the task request document.")
  public List<TesInput> getInputs() {
    return inputs;
  }

  public void setInputs(List<TesInput> inputs) {
    this.inputs = inputs;
  }

  public TesTask outputs(List<TesOutput> outputs) {
    this.outputs = outputs;
    return this;
  }

  public TesTask addOutputsItem(TesOutput outputsItem) {
    if (this.outputs == null) {
      this.outputs = new ArrayList<TesOutput>();
    }
    this.outputs.add(outputsItem);
    return this;
  }

   /**
   * Output files. Outputs will be uploaded from the executor container to long-term storage.
   * @return outputs
  **/
  @Schema(example = "[{\"path\":\"/data/outfile\",\"url\":\"s3://my-object-store/outfile-1\",\"type\":\"FILE\"}]", description = "Output files. Outputs will be uploaded from the executor container to long-term storage.")
  public List<TesOutput> getOutputs() {
    return outputs;
  }

  public void setOutputs(List<TesOutput> outputs) {
    this.outputs = outputs;
  }

  public TesTask resources(TesResources resources) {
    this.resources = resources;
    return this;
  }

   /**
   * Get resources
   * @return resources
  **/
  @Schema(description = "")
  public TesResources getResources() {
    return resources;
  }

  public void setResources(TesResources resources) {
    this.resources = resources;
  }

  public TesTask executors(List<TesExecutor> executors) {
    this.executors = executors;
    return this;
  }

  public TesTask addExecutorsItem(TesExecutor executorsItem) {
    this.executors.add(executorsItem);
    return this;
  }

   /**
   * An array of executors to be run. Each of the executors will run one at a time sequentially. Each executor is a different command that will be run, and each can utilize a different docker image. But each of the executors will see the same mapped inputs and volumes that are declared in the parent CreateTask message.  Execution stops on the first error.
   * @return executors
  **/
  @Schema(required = true, description = "An array of executors to be run. Each of the executors will run one at a time sequentially. Each executor is a different command that will be run, and each can utilize a different docker image. But each of the executors will see the same mapped inputs and volumes that are declared in the parent CreateTask message.  Execution stops on the first error.")
  public List<TesExecutor> getExecutors() {
    return executors;
  }

  public void setExecutors(List<TesExecutor> executors) {
    this.executors = executors;
  }

  public TesTask volumes(List<String> volumes) {
    this.volumes = volumes;
    return this;
  }

  public TesTask addVolumesItem(String volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<String>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

   /**
   * Volumes are directories which may be used to share data between Executors. Volumes are initialized as empty directories by the system when the task starts and are mounted at the same path in each Executor.  For example, given a volume defined at &#x60;/vol/A&#x60;, executor 1 may write a file to &#x60;/vol/A/exec1.out.txt&#x60;, then executor 2 may read from that file.  (Essentially, this translates to a &#x60;docker run -v&#x60; flag where the container path is the same for each executor).
   * @return volumes
  **/
  @Schema(example = "[\"/vol/A/\"]", description = "Volumes are directories which may be used to share data between Executors. Volumes are initialized as empty directories by the system when the task starts and are mounted at the same path in each Executor.  For example, given a volume defined at `/vol/A`, executor 1 may write a file to `/vol/A/exec1.out.txt`, then executor 2 may read from that file.  (Essentially, this translates to a `docker run -v` flag where the container path is the same for each executor).")
  public List<String> getVolumes() {
    return volumes;
  }

  public void setVolumes(List<String> volumes) {
    this.volumes = volumes;
  }

  public TesTask tags(Map<String, String> tags) {
    this.tags = tags;
    return this;
  }

  public TesTask putTagsItem(String key, String tagsItem) {
    if (this.tags == null) {
      this.tags = new HashMap<String, String>();
    }
    this.tags.put(key, tagsItem);
    return this;
  }

   /**
   * A key-value map of arbitrary tags. These can be used to store meta-data and annotations about a task. Example: &#x60;&#x60;&#x60; {   \&quot;tags\&quot; : {       \&quot;WORKFLOW_ID\&quot; : \&quot;cwl-01234\&quot;,       \&quot;PROJECT_GROUP\&quot; : \&quot;alice-lab\&quot;   } } &#x60;&#x60;&#x60;
   * @return tags
  **/
  @Schema(example = "{\"WORKFLOW_ID\":\"cwl-01234\",\"PROJECT_GROUP\":\"alice-lab\"}", description = "A key-value map of arbitrary tags. These can be used to store meta-data and annotations about a task. Example: ``` {   \"tags\" : {       \"WORKFLOW_ID\" : \"cwl-01234\",       \"PROJECT_GROUP\" : \"alice-lab\"   } } ```")
  public Map<String, String> getTags() {
    return tags;
  }

  public void setTags(Map<String, String> tags) {
    this.tags = tags;
  }

   /**
   * Task logging information. Normally, this will contain only one entry, but in the case where a task fails and is retried, an entry will be appended to this list.
   * @return logs
  **/
  @Schema(description = "Task logging information. Normally, this will contain only one entry, but in the case where a task fails and is retried, an entry will be appended to this list.")
  public List<TesTaskLog> getLogs() {
    return logs;
  }

   /**
   * Date + time the task was created, in RFC 3339 format. This is set by the system, not the client.
   * @return creationTime
  **/
  @Schema(example = "2020-10-02 10:00:00-05:00", description = "Date + time the task was created, in RFC 3339 format. This is set by the system, not the client.")
  public String getCreationTime() {
    return creationTime;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TesTask tesTask = (TesTask) o;
    return Objects.equals(this.id, tesTask.id) &&
        Objects.equals(this.state, tesTask.state) &&
        Objects.equals(this.name, tesTask.name) &&
        Objects.equals(this.description, tesTask.description) &&
        Objects.equals(this.inputs, tesTask.inputs) &&
        Objects.equals(this.outputs, tesTask.outputs) &&
        Objects.equals(this.resources, tesTask.resources) &&
        Objects.equals(this.executors, tesTask.executors) &&
        Objects.equals(this.volumes, tesTask.volumes) &&
        Objects.equals(this.tags, tesTask.tags) &&
        Objects.equals(this.logs, tesTask.logs) &&
        Objects.equals(this.creationTime, tesTask.creationTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, state, name, description, inputs, outputs, resources, executors, volumes, tags, logs, creationTime);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TesTask {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    inputs: ").append(toIndentedString(inputs)).append("\n");
    sb.append("    outputs: ").append(toIndentedString(outputs)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("    executors: ").append(toIndentedString(executors)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    logs: ").append(toIndentedString(logs)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
