/*
 * Copyright 2013-2026, Seqera Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package nextflow.module

import groovy.transform.CompileStatic
import groovy.util.logging.Slf4j
import nextflow.exception.AbortOperationException
import nextflow.script.ast.ASTUtils
import nextflow.script.ast.AssignmentExpression
import nextflow.script.ast.ProcessNode
import nextflow.script.ast.ProcessNodeV1
import nextflow.script.ast.ProcessNodeV2
import nextflow.script.ast.ScriptNode
import nextflow.script.ast.TupleParameter
import nextflow.script.control.ScriptParser
import org.codehaus.groovy.ast.Parameter
import org.codehaus.groovy.ast.expr.BinaryExpression
import org.codehaus.groovy.ast.expr.ConstantExpression
import org.codehaus.groovy.ast.expr.Expression
import org.codehaus.groovy.ast.expr.MethodCallExpression
import org.codehaus.groovy.ast.expr.VariableExpression
import org.codehaus.groovy.ast.stmt.ExpressionStatement
import org.codehaus.groovy.ast.stmt.Statement
import org.yaml.snakeyaml.DumperOptions
import org.yaml.snakeyaml.Yaml

import java.nio.file.Path

/**
 * Parses a Nextflow module's main.nf and generates the meta.yml content.
 *
 * @author Jorge Ejarque <jorge.ejarque@seqera.io>
 */
@Slf4j
@CompileStatic
class MetaYmlGenerator {

    static final String YAML_HEADER = """\
# This file was auto-generated by `nextflow module generate-meta`.
# Fields marked "TODO" require manual completion before publishing.
# Required fields: name, version, description, license, authors
"""

    // -------------------------------------------------------------------------
    // Value classes
    // -------------------------------------------------------------------------

    /**
     * Intermediate representation of a channel input or output declaration.
     */
    static class ChannelEntry {
        String identifier
        String qualifier
        String declaredType
        String resolvedType
        List<ChannelEntry> subEntries = []

        boolean isTuple() { !subEntries.isEmpty() }
    }

    /**
     * All information extracted from a single process definition.
     */
    static class ProcessMetadata {
        String name
        String syntaxVersion   // 'V1' or 'V2'
        List<ChannelEntry> inputs = []
        List<ChannelEntry> outputs = []
    }

    // -------------------------------------------------------------------------
    // Public API
    // -------------------------------------------------------------------------

    /**
     * Parse {@code mainNfPath}, extract the first process definition, and
     * return a {@link ProcessMetadata} describing its inputs and outputs.
     *
     * @param mainNfPath absolute path to the module's {@code main.nf}
     * @return the extracted metadata
     * @throws AbortOperationException if no process definition is found
     */
    static ProcessMetadata extract(Path mainNfPath) {
        final source = mainNfPath.text
        final parser = new ScriptParser()
        final sourceUnit = parser.parse(mainNfPath.toString(), source)
        final unit = sourceUnit.getAST() as ScriptNode
        if( !unit ){
            throw new AbortOperationException("Error parsing ${mainNfPath}")
        }
        final processes = unit.getProcesses()
        if( processes.isEmpty() ) {
            throw new AbortOperationException("No processes found in ${mainNfPath}")
        }
        if( processes.size() > 1 )
            log.warn "Multiple process definitions found in ${mainNfPath}; only '${processes[0].name}' will be used"
        final process = processes[0] as ProcessNode
        return visitProcess(process)
    }

    /**
     * Render a {@link ProcessMetadata} as a YAML string (with comment header).
     *
     * @param meta the extracted metadata
     * @return the generated meta.yml content
     */
    static String render(ProcessMetadata meta) {
        final manifest = buildManifest(meta)
        final opts = new DumperOptions()
        opts.defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
        opts.indent = 2
        opts.prettyFlow = true
        final yaml = new Yaml(opts)
        return YAML_HEADER + yaml.dump(manifest)
    }

    // -------------------------------------------------------------------------
    // Manifest builder
    // -------------------------------------------------------------------------

    private static LinkedHashMap<String, Object> buildManifest(ProcessMetadata meta) {
        final manifest = new LinkedHashMap<String, Object>()
        manifest['name'] = ('<scope-placeholder>/' + meta.name.toLowerCase())
        manifest['version'] = '0.0.1'
        manifest['description'] = 'TODO: Add description'
        manifest['license'] = 'TODO: Add license (e.g., MIT)'
        manifest['authors'] = ['TODO: Add author']
        manifest['tools'] = buildToolsPlaceholder()
        if( meta.inputs )
            manifest['input'] = buildChannelList(meta.inputs)
        if( meta.outputs )
            manifest['output'] = buildChannelList(meta.outputs)
        return manifest
    }

    private static List buildToolsPlaceholder() {
        final toolSpec = new LinkedHashMap<String, Object>()
        toolSpec['description'] = 'TODO: Add tool description'
        toolSpec['homepage'] = 'TODO: Add homepage URL'
        toolSpec['documentation'] = 'TODO: Add documentation URL'
        toolSpec['licence'] = ['TODO: Add licence']
        return [['TODO-tool-name': toolSpec]]
    }

    private static List buildChannelList(List<ChannelEntry> entries) {
        final result = []
        for( final ChannelEntry entry : entries ) {
            if( entry.isTuple() ) {
                for( final ChannelEntry sub : entry.subEntries ) {
                    result << buildParamSpec(sub)
                }
            } else {
                result << buildParamSpec(entry)
            }
        }
        return result
    }

    private static Map buildParamSpec(ChannelEntry entry) {
        final spec = new LinkedHashMap<String, Object>()
        spec['type'] = entry.resolvedType
        spec['description'] = 'TODO: Add description'
        return [(entry.identifier): spec] as Map
    }

    // -------------------------------------------------------------------------
    // Type mapping helpers
    // -------------------------------------------------------------------------

    static String resolveTypeFromQualifier(String qualifier, String identifier) {
        switch( qualifier ) {
            case 'val':
                return identifier == 'meta' ? 'map' : 'string'
            case 'path':
            case 'file':
                return 'file'
            case 'env':
                return 'string'
            case 'stdin':
                return 'stdin'
            case 'stdout':
                return 'stdout'
            default:
                return qualifier ?: 'TODO: add type'
        }
    }

    static String resolveTypeFromDeclaredType(String typeName) {
        // Extract simple class name (strip package prefix)
        final simple = typeName?.contains('.')
            ? typeName.tokenize('.').last()
            : typeName
        if( !simple || simple == 'Object' )
            return 'TODO: add type'
        switch( simple ) {
            case 'Path':
                return 'file'
            case 'String':
                return 'string'
            case 'Integer':
            case 'Long':
            case 'int':
            case 'long':
                return 'integer'
            case 'Float':
            case 'Double':
            case 'float':
            case 'double':
                return 'float'
            case 'Boolean':
            case 'boolean':
                return 'boolean'
            case 'Map':
                return 'map'
            default:
                return simple.toLowerCase()
        }
    }

    // -------------------------------------------------------------------------
    // ProcessExtractor (AST visitor)
    // -------------------------------------------------------------------------

    static ProcessMetadata visitProcess(ProcessNode node) {
        if( node instanceof ProcessNodeV2 )
            return visitProcessV2(node as ProcessNodeV2)
        if( node instanceof ProcessNodeV1 )
            return visitProcessV1(node as ProcessNodeV1)
    }

    static ProcessMetadata visitProcessV1(ProcessNodeV1 node) {
        final result = new ProcessMetadata(name: node.name, syntaxVersion: 'V1')
        if( node.inputs )
            result.inputs = extractV1Channels(node.inputs)
        if( node.outputs )
            result.outputs = extractV1Channels(node.outputs)
        return result

    }

    static ProcessMetadata visitProcessV2(ProcessNodeV2 node) {
        final result = new ProcessMetadata(name: node.name, syntaxVersion: 'V2')
        if( node.inputs )
            result.inputs = extractV2Inputs(node.inputs)
        final symbolMap = buildSymbolMap(node.inputs ?: new Parameter[0], node.exec)
        if( node.outputs )
            result.outputs = extractV2Outputs(node.outputs, symbolMap)
        return result
    }

    /**
     * Build a symbol map (variable name → resolved type) from:
     * 1. Process input parameters (well-typed from Parameter[])
     * 2. Variable assignments in the exec block (inferred from RHS expressions)
     * Later entries override earlier ones, so exec block assignments take priority.
     */
    private static Map<String, String> buildSymbolMap(Parameter[] inputs, Statement exec) {
        final Map<String, String> symbolMap = [:]
        // 1. Add all input parameters to the symbol map
        for( final Parameter param : inputs ) {
            if( param instanceof TupleParameter ) {
                for( final Parameter comp : (param as TupleParameter).components ) {
                    symbolMap[comp.name] = resolveTypeFromDeclaredType(simpleTypeName(comp.type?.name))
                }
            } else {
                symbolMap[param.name] = resolveTypeFromDeclaredType(simpleTypeName(param.type?.name))
            }
        }
        // 2. Walk exec block and infer types from assignments (in order, so later assignments override)
        if( exec ) {
            for( final Statement stmt : ASTUtils.asBlockStatements(exec) ) {
                if( !(stmt instanceof ExpressionStatement) )
                    continue
                final expr = (stmt as ExpressionStatement).expression
                if( !(expr instanceof BinaryExpression) )
                    continue
                final be = expr as BinaryExpression
                if( be.operation.text != '=' )
                    continue
                final left = be.leftExpression
                if( !(left instanceof VariableExpression) )
                    continue
                final name = (left as VariableExpression).name
                final inferredType = inferSimpleTypeFromExpression(be.rightExpression, symbolMap)
                if( inferredType )
                    symbolMap[name] = inferredType
            }
        }
        return symbolMap
    }

    /**
     * Infer a simple (non-tuple) resolved type from an expression using the symbol map.
     * Returns null if the type cannot be determined.
     */
    private static String inferSimpleTypeFromExpression(Expression expr, Map<String, String> symbolMap) {
        if( expr instanceof VariableExpression )
            return symbolMap[(expr as VariableExpression).name]
        if( expr instanceof ConstantExpression )
            return resolveTypeFromDeclaredType(simpleTypeName((expr as ConstantExpression).type?.name))
        if( expr instanceof MethodCallExpression ) {
            final method = (expr as MethodCallExpression).methodAsString
            if( method == 'file' || method == 'path' )
                return 'file'
        }
        return null
    }

    private static String simpleTypeName(String typeName) {
        if( !typeName ) return ''
        return typeName.contains('.') ? typeName.tokenize('.').last() : typeName
    }

    // ---- V1 extraction --------------------------------------------------

    private static List<ChannelEntry> extractV1Channels(Statement block) {
        final entries = []
        for( final Statement stmt : ASTUtils.asBlockStatements(block) ) {
            final call = ASTUtils.asMethodCallX(stmt)
            if( call ) {
                final entry = extractV1Entry(call)
                if( entry )
                    entries << entry
            }
        }
        return entries as List<ChannelEntry>
    }

    private static ChannelEntry extractV1Entry(MethodCallExpression call) {
        final qualifier = call.methodAsString
        if( qualifier == 'tuple' ) {
            return extractV1Tuple(call)
        }
        // stdin/stdout have no positional arguments
        if( qualifier == 'stdin' || qualifier == 'stdout' ) {
            return new ChannelEntry(
                identifier: qualifier,
                qualifier: qualifier,
                resolvedType: qualifier
            )
        }
        final args = ASTUtils.asMethodCallArguments(call)
        final identifier = extractIdentifierFromArgs(args)
        if( !identifier )
            return null
        return new ChannelEntry(
            identifier: identifier,
            qualifier: qualifier,
            resolvedType: resolveTypeFromQualifier(qualifier, identifier)
        )
    }

    private static ChannelEntry extractV1Tuple(MethodCallExpression call) {
        final args = ASTUtils.asMethodCallArguments(call)
        final sub = []
        for( final Expression arg : args ) {
            if( arg instanceof MethodCallExpression ) {
                final subEntry = extractV1Entry(arg as MethodCallExpression)
                if( subEntry )
                    sub << subEntry
            }
        }
        if( sub.isEmpty() )
            return null
        return new ChannelEntry(
            identifier: 'tuple',
            qualifier: 'tuple',
            resolvedType: 'tuple',
            subEntries: sub as List<ChannelEntry>
        )
    }

    private static String extractIdentifierFromArgs(List<Expression> args) {
        if( args.isEmpty() )
            return null
        final first = args[0]
        if( first instanceof VariableExpression )
            return (first as VariableExpression).name
        if( first instanceof ConstantExpression )
            return (first as ConstantExpression).text
        // For path("*.html") style — get the string literal arg
        if( first instanceof MethodCallExpression ) {
            final inner = first as MethodCallExpression
            final innerArgs = ASTUtils.asMethodCallArguments(inner)
            if( !innerArgs.isEmpty() ) {
                final innerFirst = innerArgs[0]
                if( innerFirst instanceof ConstantExpression )
                    return (innerFirst as ConstantExpression).text
                if( innerFirst instanceof VariableExpression )
                    return (innerFirst as VariableExpression).name
            }
        }
        return null
    }

    // ---- V2 extraction --------------------------------------------------

    private static List<ChannelEntry> extractV2Inputs(Parameter[] params) {
        final entries = []
        for( final Parameter param : params ) {
            if( param instanceof TupleParameter ) {
                entries << extractV2TupleInput(param as TupleParameter)
            } else {
                entries << extractV2SimpleParam(param)
            }
        }
        return entries as List<ChannelEntry>
    }

    private static ChannelEntry extractV2TupleInput(TupleParameter tp) {
        final sub = []
        for( final Parameter component : tp.components ) {
            sub << extractV2SimpleParam(component)
        }
        return new ChannelEntry(
            identifier: tp.name,
            qualifier: 'tuple',
            resolvedType: 'tuple',
            subEntries: sub as List<ChannelEntry>
        )
    }

    private static ChannelEntry extractV2SimpleParam(Parameter param) {
        final typeName = param.type?.name ?: ''
        final simpleTypeName = typeName.contains('.')
            ? typeName.tokenize('.').last()
            : typeName
        return new ChannelEntry(
            identifier: param.name,
            qualifier: 'typed',
            declaredType: simpleTypeName,
            resolvedType: resolveTypeFromDeclaredType(simpleTypeName)
        )
    }

    /**
     * Extract V2 output channel entries using a symbol map for type inference.
     *
     * Type resolution priority for each output:
     * 1. Explicit declared type annotation on the output variable (e.g. {@code bam: Path})
     * 2. Symbol map lookup for the LHS variable name (covers exec block overrides and inputs)
     * 3. RHS expression inference: {@code file()/path()} → file, {@code tuple()} → tuple with sub-entries,
     *    variable reference → symbol map lookup, constant → type from constant
     * 4. Fallback to {@code 'TODO: add type'}
     */
    private static List<ChannelEntry> extractV2Outputs(Statement block, Map<String, String> symbolMap) {
        final entries = []
        for( final Statement stmt : ASTUtils.asBlockStatements(block) ) {
            if( !(stmt instanceof ExpressionStatement) )
                continue
            final expr = (stmt as ExpressionStatement).expression

            if( expr instanceof VariableExpression ) {
                // e.g. `bam: Path`  — declared type annotation only, no assignment
                final varExpr = expr as VariableExpression
                final simple = simpleTypeName(varExpr.type?.name)
                final resolvedType = (simple && simple != 'Object')
                    ? resolveTypeFromDeclaredType(simple)
                    : (symbolMap.containsKey(varExpr.name) ? symbolMap[varExpr.name] : 'TODO: add type')
                entries << new ChannelEntry(
                    identifier: varExpr.name,
                    qualifier: 'typed',
                    declaredType: simple,
                    resolvedType: resolvedType
                )

            } else if( expr instanceof AssignmentExpression ) {
                final assign = expr as AssignmentExpression
                final left = assign.leftExpression
                if( !(left instanceof VariableExpression) )
                    continue
                final varExpr = left as VariableExpression
                final name = varExpr.name
                final simple = simpleTypeName(varExpr.type?.name)

                // 1. Explicit declared type on LHS (e.g. `outBam: Path = ...`)
                if( simple && simple != 'Object' ) {
                    entries << new ChannelEntry(
                        identifier: name,
                        qualifier: 'typed',
                        declaredType: simple,
                        resolvedType: resolveTypeFromDeclaredType(simple)
                    )
                    continue
                }

                // 2. Symbol map lookup for the LHS name (exec block overrides take priority)
                if( symbolMap.containsKey(name) ) {
                    entries << new ChannelEntry(
                        identifier: name,
                        qualifier: 'typed',
                        resolvedType: symbolMap[name]
                    )
                    continue
                }

                // 3. Infer from the RHS expression
                final right = assign.rightExpression
                if( right instanceof MethodCallExpression ) {
                    final method = (right as MethodCallExpression).methodAsString
                    if( method == 'tuple' ) {
                        final sub = extractTupleSubEntries(right as MethodCallExpression, symbolMap)
                        entries << new ChannelEntry(
                            identifier: name,
                            qualifier: 'tuple',
                            resolvedType: 'tuple',
                            subEntries: sub
                        )
                        continue
                    }
                    if( method == 'file' || method == 'path' ) {
                        entries << new ChannelEntry(
                            identifier: name,
                            qualifier: 'typed',
                            resolvedType: 'file'
                        )
                        continue
                    }
                }
                final inferredType = inferSimpleTypeFromExpression(right, symbolMap)
                entries << new ChannelEntry(
                    identifier: name,
                    qualifier: 'typed',
                    resolvedType: inferredType ?: 'TODO: add type'
                )
            }
        }
        return entries as List<ChannelEntry>
    }

    /**
     * Extract sub-entries from a {@code tuple(...)} method call expression.
     * Each argument is resolved against the symbol map:
     * - {@code VariableExpression} → look up name in symbol map
     * - {@code file(pattern)} / {@code path(pattern)} → file type, identifier from first arg
     */
    private static List<ChannelEntry> extractTupleSubEntries(MethodCallExpression tupleCall, Map<String, String> symbolMap) {
        final sub = []
        for( final Expression arg : ASTUtils.asMethodCallArguments(tupleCall) ) {
            if( arg instanceof VariableExpression ) {
                final argName = (arg as VariableExpression).name
                sub << new ChannelEntry(
                    identifier: argName,
                    qualifier: 'typed',
                    resolvedType: symbolMap[argName] ?: 'TODO: add type'
                )
            } else if( arg instanceof MethodCallExpression ) {
                final method = (arg as MethodCallExpression).methodAsString
                if( method == 'file' || method == 'path' ) {
                    final argArgs = ASTUtils.asMethodCallArguments(arg as MethodCallExpression)
                    final identifier = (!argArgs.isEmpty() && argArgs[0] instanceof ConstantExpression)
                        ? (argArgs[0] as ConstantExpression).text
                        : method
                    sub << new ChannelEntry(identifier: identifier, qualifier: method, resolvedType: 'file')
                }
            }
        }
        return sub as List<ChannelEntry>
    }
}
