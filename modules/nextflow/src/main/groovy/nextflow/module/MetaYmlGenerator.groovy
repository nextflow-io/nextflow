/*
 * Copyright 2013-2026, Seqera Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package nextflow.module

import groovy.transform.CompileStatic
import groovy.util.logging.Slf4j
import nextflow.exception.AbortOperationException
import nextflow.script.ast.ASTUtils
import nextflow.script.ast.AssignmentExpression
import nextflow.script.ast.ProcessNode
import nextflow.script.ast.ProcessNodeV1
import nextflow.script.ast.ProcessNodeV2
import nextflow.script.ast.ScriptNode
import nextflow.script.ast.TupleParameter
import nextflow.script.control.ScriptParser
import org.codehaus.groovy.ast.Parameter
import org.codehaus.groovy.ast.expr.BinaryExpression
import org.codehaus.groovy.ast.expr.ConstantExpression
import org.codehaus.groovy.ast.expr.Expression
import org.codehaus.groovy.ast.expr.MapEntryExpression
import org.codehaus.groovy.ast.expr.MethodCallExpression
import org.codehaus.groovy.ast.expr.NamedArgumentListExpression
import org.codehaus.groovy.ast.expr.VariableExpression
import org.codehaus.groovy.ast.stmt.ExpressionStatement
import org.codehaus.groovy.ast.stmt.Statement
import org.yaml.snakeyaml.DumperOptions
import org.yaml.snakeyaml.Yaml

import java.nio.file.Path

/**
 * Parses a Nextflow module's main.nf and generates the meta.yml content.
 *
 * @author Jorge Ejarque <jorge.ejarque@seqera.io>
 */
@Slf4j
@CompileStatic
class MetaYmlGenerator {

    static final String YAML_HEADER = """\
# This file was auto-generated by `nextflow module generate-meta`.
# Review and complete all fields marked "TODO" before publishing.
#
# Auto-detected types to verify:
#   - val: inferred as 'string'; use 'map' for structured meta objects
#   - path: glob patterns (*, ?, {}, []) -> 'list'; literal filenames -> 'file'
#           explicit arity: '1' -> 'file'; arity: '1..*' -> 'list'
#
"""

    // -------------------------------------------------------------------------
    // Value classes
    // -------------------------------------------------------------------------

    /**
     * Intermediate representation of a channel input or output declaration.
     */
    static class ChannelEntry {
        String identifier
        String qualifier
        String declaredType
        String resolvedType
        List<ChannelEntry> subEntries = []

        boolean isTuple() { !subEntries.isEmpty() }
    }

    /**
     * All information extracted from a single process definition.
     */
    static class ProcessMetadata {
        String name
        String syntaxVersion   // 'V1' or 'V2'
        List<ChannelEntry> inputs = []
        List<ChannelEntry> outputs = []
    }

    /**
     * Optional field overrides supplied via CLI arguments.
     * Any null field falls back to a "TODO" placeholder in the rendered YAML.
     */
    static class RenderOptions {
        String name
        String version
        String description
        String license
        List<String> authors = []
    }

    // -------------------------------------------------------------------------
    // Public API
    // -------------------------------------------------------------------------

    /**
     * Parse {@code mainNfPath}, extract the first process definition, and
     * return a {@link ProcessMetadata} describing its inputs and outputs.
     *
     * @param mainNfPath absolute path to the module's {@code main.nf}
     * @return the extracted metadata
     * @throws AbortOperationException if no process definition is found
     */
    static ProcessMetadata extract(Path mainNfPath) {
        final source = mainNfPath.text
        final parser = new ScriptParser()
        final sourceUnit = parser.parse(mainNfPath.toString(), source)
        final unit = sourceUnit.getAST() as ScriptNode
        if( !unit ) {
            throw new AbortOperationException("Error parsing ${mainNfPath}")
        }
        final processes = unit.getProcesses()
        if( processes.isEmpty() ) {
            throw new AbortOperationException("No processes found in ${mainNfPath}")
        }
        if( processes.size() > 1 )
            log.warn "Multiple process definitions found in ${mainNfPath}; only '${processes[0].name}' will be used"
        final process = processes[0] as ProcessNode
        return visitProcess(process)
    }

    /**
     * Render a {@link ProcessMetadata} as a YAML string (with comment header).
     *
     * @param meta the extracted metadata
     * @return the generated meta.yml content
     */
    static String render(ProcessMetadata meta, RenderOptions renderOptions = new RenderOptions()) {
        final manifest = buildManifest(meta, renderOptions)
        final opts = new DumperOptions()
        opts.defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
        opts.indent = 2
        opts.prettyFlow = true
        final yaml = new Yaml(opts)
        return YAML_HEADER + yaml.dump(manifest)
    }

    // -------------------------------------------------------------------------
    // Manifest builder
    // -------------------------------------------------------------------------

    private static LinkedHashMap<String, Object> buildManifest(ProcessMetadata meta, RenderOptions renderOptions) {
        final manifest = new LinkedHashMap<String, Object>()
        manifest['name'] = renderOptions.name ?: ('<scope-placeholder>/' + meta.name.toLowerCase())
        manifest['version'] = renderOptions.version ?: 'TODO: Add version'
        manifest['description'] = renderOptions.description ?: 'TODO: Add module description'
        manifest['license'] = renderOptions.license ?: 'TODO: Add license (e.g., MIT)'
        manifest['authors'] = renderOptions.authors ?: ['TODO: Add author']
        if( meta.inputs )
            manifest['input'] = buildChannelList(meta.inputs)
        if( meta.outputs )
            manifest['output'] = buildChannelList(meta.outputs)
        return manifest
    }

    private static List buildChannelList(List<ChannelEntry> entries) {
        final result = []
        for( final ChannelEntry entry : entries ) {
            if( entry.isTuple() ) {
                final subList = entry.subEntries.collect { buildParamSpec(it) }
                // Named tuples (emit: name) are wrapped under their identifier
                result << (entry.identifier != 'tuple'
                    ? [(entry.identifier): subList]
                    : subList)
            } else {
                result << buildParamSpec(entry)
            }
        }
        return result
    }

    private static Map buildParamSpec(ChannelEntry entry) {
        final spec = new LinkedHashMap<String, Object>()
        spec['type'] = entry.resolvedType
        spec['description'] = 'TODO: Add description'
        return [(entry.identifier): spec] as Map
    }

    // -------------------------------------------------------------------------
    // Type mapping helpers
    // -------------------------------------------------------------------------

    static String resolveTypeFromQualifier(String qualifier, String identifier) {
        switch( qualifier ) {
            case 'val':
                return identifier == 'meta' ? 'map' : 'string'
            case 'path':
            case 'file':
                return 'file'
            case 'env':
                return 'string'
            case 'stdin':
                return 'stdin'
            case 'stdout':
                return 'stdout'
            default:
                return qualifier ?: 'TODO: add type'
        }
    }

    static String resolveTypeFromDeclaredType(String typeName) {
        // Extract simple class name (strip package prefix)
        final simple = typeName?.contains('.')
            ? typeName.tokenize('.').last()
            : typeName
        if( !simple || simple == 'Object' )
            return 'TODO: add type'
        switch( simple ) {
            case 'Path':
                return 'file'
            case 'String':
                return 'string'
            case 'Integer':
            case 'Long':
            case 'int':
            case 'long':
                return 'integer'
            case 'Float':
            case 'Double':
            case 'float':
            case 'double':
                return 'float'
            case 'Boolean':
            case 'boolean':
                return 'boolean'
            case 'Map':
                return 'map'
            default:
                return simple.toLowerCase()
        }
    }

    // -------------------------------------------------------------------------
    // ProcessExtractor (AST visitor)
    // -------------------------------------------------------------------------

    static ProcessMetadata visitProcess(ProcessNode node) {
        if( node instanceof ProcessNodeV2 )
            return visitProcessV2(node as ProcessNodeV2)
        if( node instanceof ProcessNodeV1 )
            return visitProcessV1(node as ProcessNodeV1)
    }

    static ProcessMetadata visitProcessV1(ProcessNodeV1 node) {
        final result = new ProcessMetadata(name: node.name, syntaxVersion: 'V1')
        if( node.inputs )
            result.inputs = extractV1Channels(node.inputs)
        if( node.outputs )
            result.outputs = extractV1Channels(node.outputs)
        return result

    }

    static ProcessMetadata visitProcessV2(ProcessNodeV2 node) {
        final result = new ProcessMetadata(name: node.name, syntaxVersion: 'V2')
        if( node.inputs )
            result.inputs = extractV2Inputs(node.inputs)
        final symbolMap = buildSymbolMap(node.inputs ?: new Parameter[0], node.exec)
        if( node.outputs )
            result.outputs = extractV2Outputs(node.outputs, symbolMap)
        return result
    }

    /**
     * Build a symbol map (variable name → resolved type) from:
     * 1. Process input parameters (well-typed from Parameter[])
     * 2. Variable assignments in the exec block (inferred from RHS expressions)
     * Later entries override earlier ones, so exec block assignments take priority.
     */
    private static Map<String, String> buildSymbolMap(Parameter[] inputs, Statement exec) {
        final Map<String, String> symbolMap = [:]
        // 1. Add all input parameters to the symbol map
        for( final Parameter param : inputs ) {
            if( param instanceof TupleParameter ) {
                for( final Parameter comp : (param as TupleParameter).components ) {
                    symbolMap[comp.name] = resolveTypeFromDeclaredType(simpleTypeName(comp.type?.name))
                }
            } else {
                symbolMap[param.name] = resolveTypeFromDeclaredType(simpleTypeName(param.type?.name))
            }
        }
        // 2. Walk exec block and infer types from assignments (in order, so later assignments override)
        if( exec ) {
            for( final Statement stmt : ASTUtils.asBlockStatements(exec) ) {
                if( !(stmt instanceof ExpressionStatement) )
                    continue
                final expr = (stmt as ExpressionStatement).expression
                if( !(expr instanceof BinaryExpression) )
                    continue
                final be = expr as BinaryExpression
                if( be.operation.text != '=' )
                    continue
                final left = be.leftExpression
                if( !(left instanceof VariableExpression) )
                    continue
                final name = (left as VariableExpression).name
                final inferredType = inferSimpleTypeFromExpression(be.rightExpression, symbolMap)
                if( inferredType )
                    symbolMap[name] = inferredType
            }
        }
        return symbolMap
    }

    /**
     * Infer a simple (non-tuple) resolved type from an expression using the symbol map.
     * Returns null if the type cannot be determined.
     */
    private static String inferSimpleTypeFromExpression(Expression expr, Map<String, String> symbolMap) {
        if( expr instanceof VariableExpression )
            return symbolMap[(expr as VariableExpression).name]
        if( expr instanceof ConstantExpression )
            return resolveTypeFromDeclaredType(simpleTypeName((expr as ConstantExpression).type?.name))
        if( expr instanceof MethodCallExpression ) {
            return extractMethodCallType(expr as MethodCallExpression)
        }
        return null
    }

    private static String simpleTypeName(String typeName) {
        if( !typeName ) return ''
        return typeName.contains('.') ? typeName.tokenize('.').last() : typeName
    }

    // ---- V1 extraction --------------------------------------------------

    private static List<ChannelEntry> extractV1Channels(Statement block) {
        final entries = []
        for( final Statement stmt : ASTUtils.asBlockStatements(block) ) {
            final call = ASTUtils.asMethodCallX(stmt)
            if( call ) {
                final entry = extractV1Entry(call)
                if( entry )
                    entries << entry
            }
        }
        return entries as List<ChannelEntry>
    }

    private static ChannelEntry extractV1Entry(MethodCallExpression call) {
        final qualifier = call.methodAsString
        if( qualifier == 'tuple' ) {
            return extractV1Tuple(call)
        }
        // stdin/stdout have no positional arguments
        if( qualifier == 'stdin' || qualifier == 'stdout' ) {
            return new ChannelEntry(
                identifier: qualifier,
                qualifier: qualifier,
                resolvedType: qualifier
            )
        }
        final args = ASTUtils.asMethodCallArguments(call)
        final identifier = extractIdentifierFromArgs(args)
        if( !identifier )
            return null
        final resolvedType = (qualifier == 'path' || qualifier == 'file')
            ? extractPathMethodType(call)
            : resolveTypeFromQualifier(qualifier, identifier)
        return new ChannelEntry(
            identifier: identifier,
            qualifier: qualifier,
            resolvedType: resolvedType
        )
    }

    private static ChannelEntry extractV1Tuple(MethodCallExpression call) {
        String emitName = extractEmitName(call)
        List sub = extractSubEntries(call)
        if( sub.isEmpty() )
            return null
        return new ChannelEntry(
            identifier: emitName ?: 'tuple',
            qualifier: 'tuple',
            resolvedType: 'tuple',
            subEntries: sub as List<ChannelEntry>
        )
    }

    private static List extractSubEntries(MethodCallExpression call) {
        final args = ASTUtils.asMethodCallArguments(call)
        final sub = []
        for( final Expression arg : args ) {
            if( arg instanceof MethodCallExpression ) {
                final subEntry = extractV1Entry(arg as MethodCallExpression)
                if( subEntry )
                    sub << subEntry
            }
        }
        return sub
    }

    private static String extractEmitName(MethodCallExpression call) {
        String emitName = null
        for( final MapEntryExpression namedArg : ASTUtils.asNamedArgs(call) ) {
            if( namedArg.keyExpression instanceof ConstantExpression &&
                (namedArg.keyExpression as ConstantExpression).text == 'emit' ) {
                final v = namedArg.valueExpression
                emitName = (v instanceof ConstantExpression)
                    ? (v as ConstantExpression).text
                    : (v instanceof VariableExpression ? (v as VariableExpression).name : null)
            }
        }
        return emitName
    }

    private static String extractIdentifierFromArgs(List<Expression> args) {
        if( args.isEmpty() )
            return null
        // Skip leading named-argument map (e.g. arity:'1', glob:false, etc.)
        final positional = (args[0] instanceof NamedArgumentListExpression) ? args.drop(1) : args
        if( positional.isEmpty() )
            return null
        final first = positional[0]
        if( first instanceof VariableExpression )
            return (first as VariableExpression).name
        if( first instanceof ConstantExpression )
            return (first as ConstantExpression).text
        // For path("*.html") style — get the string literal arg
        if( first instanceof MethodCallExpression ) {
            final inner = first as MethodCallExpression
            final innerArgs = ASTUtils.asMethodCallArguments(inner)
            if( !innerArgs.isEmpty() ) {
                final innerFirst = innerArgs[0]
                if( innerFirst instanceof ConstantExpression )
                    return (innerFirst as ConstantExpression).text
                if( innerFirst instanceof VariableExpression )
                    return (innerFirst as VariableExpression).name
            }
        }
        return null
    }

    // ---- V2 extraction --------------------------------------------------

    private static List<ChannelEntry> extractV2Inputs(Parameter[] params) {
        final entries = []
        for( final Parameter param : params ) {
            if( param instanceof TupleParameter ) {
                entries << extractV2TupleInput(param as TupleParameter)
            } else {
                entries << extractV2SimpleParam(param)
            }
        }
        return entries as List<ChannelEntry>
    }

    private static ChannelEntry extractV2TupleInput(TupleParameter tp) {
        final sub = []
        for( final Parameter component : tp.components ) {
            sub << extractV2SimpleParam(component)
        }
        return new ChannelEntry(
            identifier: tp.name,
            qualifier: 'tuple',
            resolvedType: 'tuple',
            subEntries: sub as List<ChannelEntry>
        )
    }

    private static ChannelEntry extractV2SimpleParam(Parameter param) {
        final typeName = param.type?.name ?: ''
        final simpleTypeName = typeName.contains('.')
            ? typeName.tokenize('.').last()
            : typeName
        return new ChannelEntry(
            identifier: param.name,
            qualifier: 'typed',
            declaredType: simpleTypeName,
            resolvedType: resolveTypeFromDeclaredType(simpleTypeName)
        )
    }

    /**
     * Extract V2 output channel entries using a symbol map for type inference.
     *
     * Type resolution priority for each output:
     * 1. Explicit declared type annotation on the output variable (e.g. {@code bam: Path})
     * 2. Symbol map lookup for the LHS variable name (covers exec block overrides and inputs)
     * 3. RHS expression inference: {@code file()/path()} → file, {@code tuple()} → tuple with sub-entries,
     *    variable reference → symbol map lookup, constant → type from constant
     * 4. Fallback to {@code 'TODO: add type'}
     */
    private static List<ChannelEntry> extractV2Outputs(Statement block, Map<String, String> symbolMap) {
        final entries = []
        for( final Statement stmt : ASTUtils.asBlockStatements(block) ) {
            if( !(stmt instanceof ExpressionStatement) )
                continue
            final expr = (stmt as ExpressionStatement).expression

            if( expr instanceof VariableExpression ) {
                // e.g. `bam: Path`  — declared type annotation only, no assignment
                entries << extractEntryFormVariable(expr as VariableExpression, symbolMap)

            } else if( expr instanceof AssignmentExpression ) {
                final assign = expr as AssignmentExpression
                if( !(assign.leftExpression instanceof VariableExpression) ) {
                    log.warn("Output not assigned to a variable: ${assign.text}")
                    continue
                }
                entries << extractEntryFormAssignment(assign, symbolMap)
            } else {
                log.warn("Output not defined as variable nor assignment: ${expr.text}")
            }
        }
        return entries as List<ChannelEntry>
    }

    private static ChannelEntry extractEntryFormAssignment(AssignmentExpression assign, Map<String, String> symbolMap) {
        final varExpr = assign.leftExpression as VariableExpression
        final name = varExpr.name
        final simple = simpleTypeName(varExpr.type?.name)

        // 1. Explicit declared type on LHS (e.g. `outBam: Path = ...`)
        if( simple && simple != 'Object' ) {
            return new ChannelEntry(
                identifier: name,
                qualifier: 'typed',
                declaredType: simple,
                resolvedType: resolveTypeFromDeclaredType(simple)
            )
        }

        // 2. Symbol map lookup for the LHS name (exec block overrides take priority)
        if( symbolMap.containsKey(name) ) {
            return new ChannelEntry(
                identifier: name,
                qualifier: 'typed',
                resolvedType: symbolMap[name]
            )
        }

        // 3. Infer from the RHS expression
        final right = assign.rightExpression
        if( right instanceof MethodCallExpression ) {
            final method = (right as MethodCallExpression).methodAsString
            if( method == 'tuple' ) {
                final sub = extractTupleSubEntries(right as MethodCallExpression, symbolMap)
                return new ChannelEntry(
                    identifier: name,
                    qualifier: 'tuple',
                    resolvedType: 'tuple',
                    subEntries: sub
                )
            }
            final methodType = extractMethodCallType(right as MethodCallExpression)
            return new ChannelEntry(
                identifier: name,
                qualifier: 'typed',
                resolvedType: methodType ?: 'TODO: add type'
            )
        }
        final inferredType = inferSimpleTypeFromExpression(right, symbolMap)
        return new ChannelEntry(
            identifier: name,
            qualifier: 'typed',
            resolvedType: inferredType ?: 'TODO: add type'
        )
    }

    private static ChannelEntry extractEntryFormVariable(VariableExpression varExpr, Map<String, String> symbolMap) {
        final simple = simpleTypeName(varExpr.type?.name)
        final resolvedType = (simple && simple != 'Object')
            ? resolveTypeFromDeclaredType(simple)
            : (symbolMap.containsKey(varExpr.name) ? symbolMap[varExpr.name] : 'TODO: add type')
        return new ChannelEntry(
            identifier: varExpr.name,
            qualifier: 'typed',
            declaredType: simple,
            resolvedType: resolvedType
        )
    }

    private static String extractMethodCallType(MethodCallExpression methodExpr) {
        final method = methodExpr.methodAsString
        if( method == 'file' ) {
            return 'file'
        }
        if( method == 'files' ) {
            return 'list'
        }
        if( (method == 'env') || (method == 'stdout') ) {
            return 'string'
        }
        if( method == 'path' ) {
            return extractPathMethodType(methodExpr)
        }
        return resolveTypeFromDeclaredType(simpleTypeName(methodExpr.methodTarget.returnType?.name))
    }

    private static String extractPathMethodType(MethodCallExpression methodExpr) {
        // Check for named 'arity' argument: arity:'1' → file, any other arity → list
        for( final MapEntryExpression entry : ASTUtils.asNamedArgs(methodExpr) ) {
            if( entry.keyExpression instanceof ConstantExpression ) {
                if( (entry.keyExpression as ConstantExpression).text == 'arity' ) {
                    final value = entry.valueExpression
                    final arity = (value instanceof ConstantExpression)
                        ? (value as ConstantExpression).text
                        : ''
                    return arity == '1' ? 'file' : 'list'
                }
            }
        }
        // No arity - use the pattern to detect glob wildcards → list, literal path → file
        final allArgs = ASTUtils.asMethodCallArguments(methodExpr)
        final namedArgs = ASTUtils.asNamedArgs(methodExpr)
        final positionalArgs = namedArgs.isEmpty() ? allArgs : allArgs.drop(1)
        if( !positionalArgs.isEmpty() && positionalArgs[0] instanceof ConstantExpression ) {
            final pattern = (positionalArgs[0] as ConstantExpression).text
            if( pattern.contains('*') || pattern.contains('?') || pattern.contains('{') || pattern.contains('[') )
                return 'list'
        }
        return 'file'
    }

    /**
     * Extract sub-entries from a {@code tuple(...)} method call expression.
     * Each argument is resolved against the symbol map:
     * - {@code VariableExpression} → look up name in symbol map
     * - {@code file(pattern)} / {@code path(pattern)} → file type, identifier from first arg
     */
    private static List<ChannelEntry> extractTupleSubEntries(MethodCallExpression tupleCall, Map<String, String> symbolMap) {
        final sub = []
        for( final Expression arg : ASTUtils.asMethodCallArguments(tupleCall) ) {
            if( arg instanceof VariableExpression ) {
                final argName = (arg as VariableExpression).name
                sub << new ChannelEntry(
                    identifier: argName,
                    qualifier: 'typed',
                    resolvedType: symbolMap[argName] ?: 'TODO: add type'
                )
            } else if( arg instanceof MethodCallExpression ) {
                final methodExpr = arg as MethodCallExpression
                final method = methodExpr.methodAsString
                final argArgs = ASTUtils.asMethodCallArguments(methodExpr)
                final positional = (argArgs && argArgs[0] instanceof NamedArgumentListExpression) ? argArgs.drop(1) : argArgs
                final identifier = (!positional.isEmpty() && positional[0] instanceof ConstantExpression)
                    ? (positional[0] as ConstantExpression).text
                    : method
                final type = extractMethodCallType(methodExpr)
                sub << new ChannelEntry(
                    identifier: identifier,
                    qualifier: 'typed',
                    resolvedType: type ?: 'TODO: add type'
                )
            }
        }
        return sub as List<ChannelEntry>
    }
}
