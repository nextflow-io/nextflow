/*
 * Copyright 2024, Seqera Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nextflow.script.control;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import nextflow.script.ast.AssignmentExpression;
import nextflow.script.ast.FeatureFlagNode;
import nextflow.script.ast.FunctionNode;
import nextflow.script.ast.IncludeNode;
import nextflow.script.ast.OutputBlockNode;
import nextflow.script.ast.ParamBlockNode;
import nextflow.script.ast.ParamNodeV1;
import nextflow.script.ast.ProcessNodeV1;
import nextflow.script.ast.ProcessNodeV2;
import nextflow.script.ast.ScriptNode;
import nextflow.script.ast.ScriptVisitorSupport;
import nextflow.script.ast.WorkflowNode;
import org.codehaus.groovy.ast.ASTNode;
import org.codehaus.groovy.ast.CodeVisitorSupport;
import org.codehaus.groovy.ast.Parameter;
import org.codehaus.groovy.ast.VariableScope;
import org.codehaus.groovy.ast.expr.BinaryExpression;
import org.codehaus.groovy.ast.expr.Expression;
import org.codehaus.groovy.ast.expr.MethodCallExpression;
import org.codehaus.groovy.ast.expr.VariableExpression;
import org.codehaus.groovy.ast.stmt.BlockStatement;
import org.codehaus.groovy.ast.stmt.ExpressionStatement;
import org.codehaus.groovy.ast.stmt.ReturnStatement;
import org.codehaus.groovy.ast.stmt.Statement;
import org.codehaus.groovy.control.SourceUnit;
import org.codehaus.groovy.runtime.DefaultGroovyMethods;
import org.codehaus.groovy.syntax.SyntaxException;
import org.codehaus.groovy.syntax.Types;

import static nextflow.script.ast.ASTUtils.*;
import static org.codehaus.groovy.ast.tools.GeneralUtils.*;

/**
 * Transform a Nextflow script AST into a Groovy AST.
 *
 * @see nextflow.script.BaseScript
 *
 * @author Ben Sherman <bentshermann@gmail.com>
 */
public class ScriptToGroovyVisitor extends ScriptVisitorSupport {

    private static Set<String> RESERVED_NAMES = Set.of("main", "run", "runScript");

    private SourceUnit sourceUnit;

    private ScriptNode moduleNode;

    private ScriptToGroovyHelper sgh;

    public ScriptToGroovyVisitor(SourceUnit sourceUnit) {
        this.sourceUnit = sourceUnit;
        this.moduleNode = (ScriptNode) sourceUnit.getAST();
        this.sgh = new ScriptToGroovyHelper(sourceUnit);
    }

    @Override
    protected SourceUnit getSourceUnit() {
        return sourceUnit;
    }

    public void visit() {
        if( moduleNode == null )
            return;
        super.visit(moduleNode);
        if( moduleNode.isEmpty() )
            moduleNode.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);
    }

    @Override
    public void visitFeatureFlag(FeatureFlagNode node) {
        var names = node.name.split("\\.");
        Expression target = varX(DefaultGroovyMethods.head(names));
        for( var name : DefaultGroovyMethods.tail(names) )
            target = propX(target, name);

        var result = stmt(assignX(target, node.value));
        moduleNode.addStatement(result);
    }

    @Override
    public void visitInclude(IncludeNode node) {
        var entries = (List<Expression>) node.entries.stream()
            .map((entry) -> {
                var name = constX(entry.name);
                return entry.alias != null
                    ? createX("nextflow.script.IncludeDef.Module", args(name, constX(entry.alias)))
                    : createX("nextflow.script.IncludeDef.Module", args(name));
            })
            .collect(Collectors.toList());

        var include = callThisX("include", args(createX("nextflow.script.IncludeDef", args(listX(entries)))));
        var from = callX(include, "from", args(node.source));
        var result = stmt(callX(from, "load0", args(varX("params"))));
        moduleNode.addStatement(result);
    }

    @Override
    public void visitParams(ParamBlockNode node) {
        var statements = Arrays.stream(node.declarations)
            .map((param) -> {
                var name = constX(param.getName());
                var type = classX(param.getType());
                var arguments = param.hasInitialExpression()
                    ? args(name, type, param.getInitialExpression())
                    : args(name, type);
                return stmt(callThisX("declare", arguments));
            })
            .toList();
        var closure = closureX(block(new VariableScope(), statements));
        var result = stmt(callThisX("params", args(closure)));
        moduleNode.addStatement(result);
    }

    @Override
    public void visitParamV1(ParamNodeV1 node) {
        var result = stmt(assignX(node.target, node.value));
        moduleNode.addStatement(result);
    }

    @Override
    public void visitWorkflow(WorkflowNode node) {
        var main = node.main instanceof BlockStatement block ? block : new BlockStatement();
        visitWorkflowEmits(node.emits, main);
        visitWorkflowPublishers(node.publishers, main);
        visitWorkflowHandler(node.onComplete, "onComplete", main);
        visitWorkflowHandler(node.onError, "onError", main);

        var bodyDef = stmt(createX(
            "nextflow.script.BodyDef",
            args(
                closureX(null, main),
                constX(getSourceText(node)),
                constX("workflow")
            )
        ));
        var closure = closureX(null, block(new VariableScope(), List.of(
            workflowTakes(node.getParameters()),
            node.emits,
            bodyDef
        )));
        var arguments = node.isEntry()
            ? args(closure)
            : args(constX(node.getName()), closure);
        var result = stmt(callThisX("workflow", arguments));
        moduleNode.addStatement(result);
    }

    private Statement workflowTakes(Parameter[] takes) {
        var statements = Arrays.stream(takes)
            .map((take) ->
                stmt(callThisX("_take_", args(constX(take.getName()))))
            )
            .toList();
        return block(null, statements);
    }

    private void visitWorkflowEmits(Statement emits, BlockStatement main) {
        for( var stmt : asBlockStatements(emits) ) {
            var es = (ExpressionStatement)stmt;
            var emit = es.getExpression();
            if( emit instanceof VariableExpression ve ) {
                es.setExpression(callThisX("_emit_", args(constX(ve.getName()))));
            }
            else if( emit instanceof AssignmentExpression ae ) {
                var target = (VariableExpression)ae.getLeftExpression();
                main.addStatement(assignS(target, emit));
                es.setExpression(callThisX("_emit_", args(constX(target.getName()))));
                main.addStatement(es);
            }
            else {
                var target = varX("$out");
                main.addStatement(assignS(target, emit));
                es.setExpression(callThisX("_emit_", args(constX(target.getName()))));
                main.addStatement(es);
            }
        }
    }

    private void visitWorkflowPublishers(Statement publishers, BlockStatement main) {
        for( var stmt : asBlockStatements(publishers) ) {
            var es = (ExpressionStatement)stmt;
            var publish = (BinaryExpression)es.getExpression();
            var target = asVarX(publish.getLeftExpression());
            es.setExpression(callThisX("_publish_", args(constX(target.getName()), publish.getRightExpression())));
            main.addStatement(es);
        }
    }

    private void visitWorkflowHandler(Statement code, String name, BlockStatement main) {
        if( code instanceof BlockStatement block )
            main.addStatement(stmt(callX(varX("workflow"), name, args(closureX(null, block)))));
    }

    @Override
    public void visitProcessV2(ProcessNodeV2 node) {
        var result = new ProcessToGroovyVisitorV2(sourceUnit).transform(node);
        moduleNode.addStatement(result);
    }

    @Override
    public void visitProcessV1(ProcessNodeV1 node) {
        var result = new ProcessToGroovyVisitorV1(sourceUnit).transform(node);
        moduleNode.addStatement(result);
    }

    @Override
    public void visitFunction(FunctionNode node) {
        if( RESERVED_NAMES.contains(node.getName()) ) {
            syntaxError(node, "`" + node.getName() + "` is not allowed as a function name because it is reserved for internal use");
            return;
        }
        moduleNode.getScriptClassDummy().addMethod(node);
    }

    @Override
    public void visitOutputs(OutputBlockNode node) {
        var statements = node.declarations.stream()
            .map((output) -> {
                new PublishDslVisitor().visit(output.body);
                var name = constX(output.name);
                var body = closureX(null, output.body);
                return stmt(callThisX("declare", args(name, body)));
            })
            .toList();
        var closure = closureX(null, block(new VariableScope(), statements));
        var result = stmt(callThisX("output", args(closure)));
        moduleNode.addStatement(result);
    }

    private String getSourceText(WorkflowNode node) {
        if( node.isEntry() && node.getLineNumber() == -1 )
            return sgh.getSourceText(node.main);

        var builder = new StringBuilder();
        var colx = node.getColumnNumber();
        var colz = node.getLastColumnNumber();
        var first = node.getLineNumber();
        var last = node.getLastLineNumber();
        for( int i = first; i <= last; i++ ) {
            var line = sourceUnit.getSource().getLine(i, null);
            if( i == last ) {
                line = line.substring(0, colz-1).replaceFirst("}.*$", "");
                if( line.trim().isEmpty() )
                    continue;
            }
            if( i == first ) {
                line = line.substring(colx-1).replaceFirst("^.*\\{", "").trim();
                if( line.isEmpty() )
                    continue;
            }
            builder.append(line).append('\n');
        }
        return builder.toString();
    }

    private void syntaxError(ASTNode node, String message) {
        sourceUnit.addError(new SyntaxException(message, node));
    }

    /**
     * Transform publish statements in a workflow output:
     *
     *   path { sample ->
     *     sample.foo >> 'foo/'
     *     sample.bar >> 'bar/'
     *   }
     *
     * becomes:
     *
     *   path { sample ->
     *     publish(sample.foo, 'foo/')
     *     publish(sample.bar, 'bar/')
     *   }
     */
    private class PublishDslVisitor extends CodeVisitorSupport {

        private boolean hasPublishStatements;

        private boolean hasNonPublishStatements;

        @Override
        public void visitMethodCallExpression(MethodCallExpression node) {
            if( "path".equals(node.getMethodAsString()) )
                visitPathDirective(node);
        }

        private void visitPathDirective(MethodCallExpression node) {
            var code = asDslBlock(node, 1);
            if( code == null )
                return;
            for( var stmt : code.getStatements() ) {
                if( visitPublishStatement(stmt) )
                    hasPublishStatements = true;
                else
                    hasNonPublishStatements = true;
            }
            if( hasPublishStatements && hasNonPublishStatements )
                syntaxError(node, "Publish statements cannot be mixed with other statements in a dynamic publish path");
        }

        private boolean visitPublishStatement(Statement node) {
            if( !(node instanceof ExpressionStatement) )
                return false;
            var es = (ExpressionStatement) node;
            if( !(es.getExpression() instanceof BinaryExpression) )
                return false;
            var be = (BinaryExpression) es.getExpression();
            if( be.getOperation().getType() != Types.RIGHT_SHIFT )
                return false;
            var source = be.getLeftExpression();
            var target = be.getRightExpression();
            es.setExpression(callThisX("publish", args(source, target)));
            return true;
        }
    }

}
